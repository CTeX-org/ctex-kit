%%
%% Copyright (C) 2012 by Qing Lee <sobenlee@gmail.com>
%% --------------------------------------------------------------------------
%% This work may be distributed and/or modified under the
%% conditions of the LaTeX Project Public License, either version 1.3
%% of this license or (at your option) any later version.
%% The latest version of this license is in
%%   http://www.latex-project.org/lppl.txt
%% and version 1.3 or later is part of all distributions of LaTeX
%% version 2005/12/01 or later.
%%
%% This work has the LPPL maintenance status `author-maintained'.
%%
%%
\RequirePackage{l3keys2e}
\ProvidesExplPackage {zhnumber} {2012/04/18} {1.2}
  {package for typesetting numbers with Chinese glyphs}

\int_const:Nn \c_hundred_million { 100 000 000 }

\cs_new_nopar:Nn \zhnum_units:n     { \int_mod:nn {#1} \c_ten }
\cs_new_nopar:Nn \zhnum_tens:n      { \int_mod:nn { \int_div_truncate:nn {#1} \c_ten } \c_ten }
\cs_new_nopar:Nn \zhnum_hundreds:n  { \int_mod:nn { \int_div_truncate:nn {#1} \c_one_hundred } \c_ten }
\cs_new_nopar:Nn \zhnum_thousands:n { \int_div_truncate:nn {#1} \c_one_thousand }

\cs_new_nopar:Nn \zhnum_process_number:nn
  {
    \int_compare:nNnTF { \zhnum_thousands:n {#2} } = \c_zero
      {
        \int_compare:nNnT {#1} = \c_zero
          { \zhnum_digit_map:n \c_zero }
      }
      {
        \zhnum_digit_map:n { \zhnum_thousands:n {#2} }
        \zhnum_digit_map:n \c_one_thousand
      }
    \int_compare:nNnTF { \zhnum_hundreds:n {#2} } = \c_zero
      {
        \bool_if:nT
          {
            \int_compare_p:nNn { \zhnum_thousands:n {#2} }         > \c_zero &&
            \int_compare_p:nNn { \int_mod:nn {#2} \c_one_hundred } > \c_zero
          }
          { \zhnum_digit_map:n \c_zero }
      }
      {
        \bool_if:nTF
          {
            \l_zhnum_ancient_bool                                  &&
            \int_compare_p:nNn { \zhnum_hundreds:n {#2} } = \c_two
          }
          { \zhnum_digit_map:n { \zhnum_hundreds:n {#2} * \c_one_hundred } }
          {
            \zhnum_digit_map:n { \zhnum_hundreds:n {#2} }
            \zhnum_digit_map:n \c_one_hundred
          }
      }
    \int_compare:nNnTF { \zhnum_tens:n {#2} } = \c_zero
      {
        \bool_if:nT
          {
            \int_compare_p:nNn { \zhnum_hundreds:n {#2} } > \c_zero &&
            \int_compare_p:nNn { \zhnum_units:n    {#2} } > \c_zero
          }
          { \zhnum_digit_map:n \c_zero }
      }
      {
        \bool_if:nF
          {
            \int_compare_p:nNn { \zhnum_tens:n {#2} } = \c_one &&
            \int_compare_p:nNn {#2} < \c_one_hundred           &&
            ! ( \int_compare_p:nNn {#1} = \c_zero )
          }
          {
            \bool_if:nTF
              {
                \l_zhnum_ancient_bool                                     &&
                ( \int_compare_p:nNn { \zhnum_tens:n {#2} } = \c_two   ||
                  \int_compare_p:nNn { \zhnum_tens:n {#2} } = \c_three ||
                  \int_compare_p:nNn { \zhnum_tens:n {#2} } = \c_four )
              }
              {
                \zhnum_digit_map:n { \zhnum_tens:n {#2} * \c_ten }
                \use_none:nn
              }
              { \zhnum_digit_map:n { \zhnum_tens:n {#2} } }
          }
        \zhnum_digit_map:n \c_ten
      }
    \int_compare:nNnF { \zhnum_units:n {#2} } = \c_zero
      { \zhnum_digit_map:n { \zhnum_units:n {#2} } }
  }

\cs_new_nopar:Nn \zhnum_number:n
  {
    \int_compare:nNnTF {#1} < \c_hundred_million
      {
        \int_compare:nNnTF {#1} < \c_ten_thousand
          {
            \int_compare:nNnTF {#1} = \c_zero
              { \zhnum_digit_map:n \c_zero }
              { \zhnum_process_number:nn \c_one {#1} }
          }
          {
            \zhnum_process_number:nn \c_one { \int_div_truncate:nn {#1} \c_ten_thousand }
            \zhnum_digit_map:n \c_ten_thousand
            \int_compare:nNnF { \int_mod:nn {#1} \c_ten_thousand } = \c_zero
              { \zhnum_process_number:nn \c_zero { \int_mod:nn {#1} \c_ten_thousand } }
          }
      }
      {
        \zhnum_process_number:nn \c_one { \int_div_truncate:nn {#1} \c_hundred_million }
        \zhnum_digit_map:n \c_hundred_million
        \int_compare:nNnF { \int_mod:nn {#1} \c_hundred_million } = \c_zero
          {
            \int_compare:nNnTF { \int_mod:nn {#1} \c_hundred_million } < \c_ten_thousand
              {
                \int_compare:nNnF { \int_mod:nn {#1} \c_hundred_million } < \c_one_thousand
                  { \zhnum_digit_map:n \c_zero }
              }
              {
                \zhnum_process_number:nn \c_zero
                  { \int_mod:nn { \int_div_truncate:nn {#1} \c_ten_thousand } \c_ten_thousand }
                \zhnum_digit_map:n \c_ten_thousand
              }
            \int_compare:nNnF { \int_mod:nn {#1} \c_ten_thousand } = \c_zero
              { \zhnum_process_number:nn \c_zero { \int_mod:nn {#1} \c_ten_thousand } }
          }
      }
  }

\cs_new_nopar:Nn \zhnum_integer:n
  {
    \int_compare:nNnT { \zhnum_erase_comma:f {#1} } < \c_zero
      { \zhnum_digit_map:n \c_minus_one }
    \zhnum_number:n { \int_abs:n { \zhnum_erase_comma:f {#1} } }
  }

\cs_new_nopar:Npn \zhnum #1
  {
    \exp_args:Nc \token_if_int_register:NTF { c@#1 }
      { \exp_args:Nv \zhnum_integer:n { c@#1 } }
      { \@nocounterr {#1} }
  }

\cs_new_nopar:Npn \zhnumber #1 { \zhnum_number:w #1 . \q_nil . \q_stop }

\cs_new_nopar:Npn \zhnum_number:w #1.#2.#3 \q_stop
  {
    \quark_if_nil:nTF {#2}
      { \zhnum_integer_or_fraction:w #1 / \q_nil / \q_stop }
      { \zhnum_decimal:nn {#1} {#2} }
  }

\cs_new_nopar:Npn \zhnum_integer_or_fraction:w #1/#2/#3 \q_stop
  {
    \quark_if_nil:nTF {#2}
      { \zhnum_integer:n {#1} }
      { \zhnum_fraction:w #2 \q_mark #1 ; \q_nil ; \q_stop }
  }

\cs_new_nopar:Npn \zhnum_fraction:w #1 \q_mark #2;#3;#4 \q_stop
  {
    \quark_if_nil:nTF {#3}
      {
        \zhnum_blank_to_zero:f {#1} \c_zhnum_over_tl
        \zhnum_blank_to_zero:f {#2}
      }
      {
        \tl_if_blank:fF {#2} { \zhnumber {#2} \c_zhnum_and_tl }
        \zhnum_blank_to_zero:f {#1} \c_zhnum_over_tl
        \zhnum_blank_to_zero:f {#3}
      }
  }

\cs_new_nopar:Nn \zhnum_decimal:nn
  {
    \zhnum_blank_to_zero:f {#1} \c_zhnum_dot_tl
    \tl_if_blank:fTF {#2} { \zhnum_digit_map:n \c_zero } { \zhdigits * {#2} }
  }

\cs_new_nopar:Nn \zhnum_blank_to_zero:n
  { \tl_if_blank:nTF {#1} { \zhnum_digit_map:n \c_zero } { \zhnumber {#1} } }

\cs_generate_variant:Nn \zhnum_blank_to_zero:n { f }
\cs_generate_variant:Nn \tl_reverse:n          { f }
\cs_generate_variant:Nn \tl_if_blank:nTF       { f }
\cs_generate_variant:Nn \tl_if_blank:nF        { f }
\cs_generate_variant:Nn \tl_map_function:nN    { f }

\DeclareExpandableDocumentCommand \zhdigits { s m }
  {
    \IfBooleanTF #1
      { \tl_map_function:fN {#2} \zhnum_digits_zero_aux:N }
      { \tl_map_function:fN {#2} \zhnum_digits_null_aux:N }
  }

\cs_new_nopar:Nn \zhnum_digits_null_aux:N { \zhnum_digits_aux:nn \c_zhnum_null_int {#1} }
\cs_new_nopar:Nn \zhnum_digits_zero_aux:N { \zhnum_digits_aux:nn \c_zero {#1} }

\cs_new_nopar:Nn \zhnum_digits_aux:nn
  {
    \str_if_eq:xxF {#2} ,
      {
        \str_if_eq:xxTF {#2} . \c_zhnum_dot_tl
          {
            \zhnum_digit_map:n
              {
                \str_if_eq:xxTF {#2} - \c_minus_one
                  {
                    \bool_if:nTF
                      {
                        \int_compare_p:nNn {#2} = \c_zero           &&
                        \int_compare_p:nNn {#1} = \c_zhnum_null_int
                      }
                      { \c_zhnum_null_int } {#2}
                  }
              }
          }
      }
  }

\cs_new_nopar:Nn \zhnum_erase_comma:n
  { \tl_map_function:nN {#1} \zhnum_erase_comma_aux:N }

\cs_new_nopar:Nn \zhnum_erase_comma_aux:N
  { \str_if_eq:xxF {#1} , {#1} }

\cs_generate_variant:Nn \zhnum_erase_comma:n { f }

\int_const:Nn \c_zhnum_null_int { -10 }

\cs_new_nopar:Nn \zhnum_digit_map:n
  {
    \prg_case_int:nnn {#1}
      {
        { \c_minus_one       } { \c_zhnum_minus_tl          }
        { \c_zero            } { \c_zhnum_zero_tl           }
        { \c_one             } { \c_zhnum_one_tl            }
        { \c_two             } { \c_zhnum_two_tl            }
        { \c_three           } { \c_zhnum_three_tl          }
        { \c_four            } { \c_zhnum_four_tl           }
        { \c_five            } { \c_zhnum_five_tl           }
        { \c_six             } { \c_zhnum_six_tl            }
        { \c_seven           } { \c_zhnum_seven_tl          }
        { \c_eight           } { \c_zhnum_eight_tl          }
        { \c_nine            } { \c_zhnum_nine_tl           }
        { \c_ten             } { \c_zhnum_ten_tl            }
        { \c_one_hundred     } { \c_zhnum_hundred_tl        }
        { \c_one_thousand    } { \c_zhnum_thousand_tl       }
        { \c_ten_thousand    } { \c_zhnum_tenthousand_tl    }
        { \c_hundred_million } { \c_zhnum_hundredmillion_tl }
        { \c_zhnum_null_int  } { \c_zhnum_null_tl           }
        { 20                 } { \c_zhnum_twenty_tl         }
        { 30                 } { \c_zhnum_thirty_tl         }
        { 40                 } { \c_zhnum_forty_tl          }
        { 200                } { \c_zhnum_two_hundred_tl    }
      }
      { \prg_do_nothing: }
  }

\keys_define:nn { zhnum / options }
  {
    -   .tl_set:N = \c_zhnum_minus_tl          ,
    -0  .tl_set:N = \c_zhnum_null_tl           ,
    0   .tl_set:N = \c_zhnum_zero_tl           ,
    1   .tl_set:N = \c_zhnum_one_tl            ,
    2   .tl_set:N = \c_zhnum_two_tl            ,
    3   .tl_set:N = \c_zhnum_three_tl          ,
    4   .tl_set:N = \c_zhnum_four_tl           ,
    5   .tl_set:N = \c_zhnum_five_tl           ,
    6   .tl_set:N = \c_zhnum_six_tl            ,
    7   .tl_set:N = \c_zhnum_seven_tl          ,
    8   .tl_set:N = \c_zhnum_eight_tl          ,
    9   .tl_set:N = \c_zhnum_nine_tl           ,
    10  .tl_set:N = \c_zhnum_ten_tl            ,
    20  .tl_set:N = \c_zhnum_twenty_tl         ,
    30  .tl_set:N = \c_zhnum_thirty_tl         ,
    40  .tl_set:N = \c_zhnum_forty_tl          ,
    200 .tl_set:N = \c_zhnum_two_hundred_tl    ,
    E2  .tl_set:N = \c_zhnum_hundred_tl        ,
    E3  .tl_set:N = \c_zhnum_thousand_tl       ,
    E4  .tl_set:N = \c_zhnum_tenthousand_tl    ,
    E8  .tl_set:N = \c_zhnum_hundredmillion_tl ,
  }

\cs_new:Nn \zhnum_load_cfg:
  {
    \file_input:n
      { zhnum - \bool_if:NTF \g_zhnum_gbk_bool { gbk } { utf8 } .cfg }
  }

\keys_define:nn { zhnum / options }
  {
    encoding .choice: ,
    encoding / UTF8     .code:n = { \bool_gset_false:N \g_zhnum_gbk_bool \zhnum_load_cfg: } ,
    encoding / GBK      .code:n = { \bool_gset_true:N  \g_zhnum_gbk_bool \zhnum_load_cfg: } ,
    encoding         .default:n = { GBK } ,
    style .multichoice: ,
    style / Normal      .code:n =
      {
        \bool_set_false:N \l_zhnum_ancient_bool
        \bool_set_true:N  \l_zhnum_normal_bool
      } ,
    style / Financial   .code:n =
      {
        \bool_set_false:N \l_zhnum_ancient_bool
        \bool_set_false:N \l_zhnum_normal_bool
      } ,
    style / Ancient     .code:n =
      {
        \bool_set_true:N \l_zhnum_ancient_bool
        \bool_set_true:N \l_zhnum_normal_bool
      } ,
    style / Simplified  .code:n = { \bool_set_true:N  \l_zhnum_simp_bool } ,
    style / Traditional .code:n = { \bool_set_false:N \l_zhnum_simp_bool } ,
    style            .default:n = { Normal , Simplified } ,
    null            .bool_set:N = \l_zhnum_null_bool ,
    reset               .code:n = \zhnum_load_cfg: ,
    dot               .tl_set:N = \c_zhnum_dot_tl  ,
    and               .tl_set:N = \c_zhnum_and_tl  ,
    over              .tl_set:N = \c_zhnum_over_tl ,
  }

\NewDocumentCommand \zhnumsetup { m }
  {
    \keys_set:nn { zhnum / options } {#1}
    \tex_ignorespaces:D
  }

\cs_generate_variant:Nn \keys_set:nn { nx }

\keys_set:nx { zhnum / options }
  {
    encoding = { \xetex_if_engine:TF { UTF8 } { GBK } } ,
    style , null = false ,
  }

\ExplSyntaxOn

\ProcessKeysOptions { zhnum / options }

\endinput
%%
